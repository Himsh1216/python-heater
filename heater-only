import tkinter as tk
from tkinter import ttk
import threading
import time
import csv
import os
import serial
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from tenmaDcLib import instantiate_tenma_class_from_device_response

try:
    import adafruit_max31865 as max31865
except ModuleNotFoundError:
    print("Error: The module 'adafruit_max31865' is not installed. "
          "Please install it using 'pip install adafruit-circuitpython-max31865'.")
    exit()

import board
import busio
import digitalio


# ---------------------------------------------------
# PID Controller
# ---------------------------------------------------
class PIDController:
    def __init__(self, kc=1.5, ti=3.0, td=0.5, delta_t=0.01, theta=0.2, integral_limit=100):
        """
        A simple PID controller with a time-delay buffer.
        :param kc: Controller gain
        :param ti: Integral time
        :param td: Derivative time
        :param delta_t: Sampling time
        :param theta: Time delay for simulating lag
        :param integral_limit: Limit for integral wind-up
        """
        self.kc = kc
        self.ti = ti
        self.td = td
        self.delta_t = delta_t
        self.theta = theta
        self.integral_limit = integral_limit
        self.previous_error = 0
        self.integral = 0
        self.derivative_filter = 0

        # A simple buffer to simulate time delay (theta)
        num_delay_points = max(1, int(theta / delta_t))
        self.time_delay_buffer = [0] * num_delay_points

    def compute(self, setpoint, current_temp):
        """
        Compute the PID output.
        :param setpoint: Desired temperature setpoint
        :param current_temp: Current temperature reading
        :return: PID output (limited between 0 and 3)
        """
        # Simulate time delay using FIFO buffer
        self.time_delay_buffer.append(current_temp)
        current_temp_delayed = self.time_delay_buffer.pop(0)

        # Error
        error = setpoint - current_temp_delayed

        # Integral term with wind-up guard
        self.integral += error * self.delta_t
        self.integral = max(-self.integral_limit, min(self.integral, self.integral_limit))

        # Derivative
        derivative = (error - self.previous_error) / self.delta_t

        # PID output
        proportional = self.kc * error
        integral_term = (self.kc / self.ti) * self.integral
        derivative_term = self.kc * self.td * derivative
        output = proportional + integral_term + derivative_term

        self.previous_error = error
        print(f"Error: {error:.2f}, P: {proportional:.2f}, I: {integral_term:.2f}, "
              f"D: {derivative_term:.2f}, Output: {output:.2f}")

        # Clamp output in [0, 3] amps
        return max(0, min(output, 3))


# ---------------------------------------------------
# Heater Control Application
# ---------------------------------------------------
class HeaterControlApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Temperature Control System")
        self.root.geometry("1000x800")
        self.running = False
        self.is_logged_in = False

        # Initialize sensor (MAX31865)
        try:
            spi = busio.SPI(board.SCK, MOSI=board.MOSI, MISO=board.MISO)
            cs = digitalio.DigitalInOut(board.D5)
            self.sensor = max31865.MAX31865(spi, cs, wires=2, ref_resistor=430.0)
        except Exception as e:
            print(f"Error initializing MAX31865 sensor: {e}")
            self.sensor = None

        # Initialize the single power supply (Tenma 2540)
        self.power_supply = self.initialize_power_supply()

        # PID controller
        self.pid = PIDController(kc=1.5, ti=3.0, td=0.5)

        # Variables
        self.current_temp = tk.DoubleVar(value=0.0)
        self.set_temp = tk.DoubleVar(value=30.0)
        self.current_output = tk.DoubleVar(value=0.0)
        self.connection_status = tk.BooleanVar(value=False)
        self.error_message = tk.StringVar(value="")
        self.temp_profiles = []
        self.initial_temp = tk.DoubleVar(value=25.0)
        self.is_processing = tk.BooleanVar(value=False)
        self.heat_sink_temp = tk.DoubleVar(value=0.0)

        # Setup login GUI
        self.setup_login_gui()

        # CSV logging
        self.data_log_file = "temperature_log.csv"
        self.setup_logging()

        # For plotting
        self.time_stamps = []
        self.temperatures = []
        self.start_time = time.time()

    # ------------------------------------------------
    # Power Supply Initialization
    # ------------------------------------------------
    def initialize_power_supply(self):
        """
        Try to connect to the Tenma 2540 power supply. Modify serial port as needed.
        """
        try:
            port = '/dev/ttyACM0'
            return instantiate_tenma_class_from_device_response(port)
        except Exception as e:
            print(f"Error connecting to power supply: {e}")
            return None

    # ------------------------------------------------
    # Login GUI
    # ------------------------------------------------
    def setup_login_gui(self):
        self.login_frame = ttk.Frame(self.root)
        self.login_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        ttk.Label(self.login_frame, text="Login", font=("Arial", 16, "bold")).pack(pady=10)

        self.username_var = tk.StringVar()
        self.password_var = tk.StringVar()

        ttk.Label(self.login_frame, text="Username:").pack()
        ttk.Entry(self.login_frame, textvariable=self.username_var).pack(pady=5)

        ttk.Label(self.login_frame, text="Password:").pack()
        ttk.Entry(self.login_frame, textvariable=self.password_var, show="*").pack(pady=5)

        ttk.Button(self.login_frame, text="Login", command=self.handle_login).pack(pady=10)

    def handle_login(self):
        username = self.username_var.get()
        password = self.password_var.get()

        if username == "admin" and password == "password":
            self.is_logged_in = True
            self.login_frame.pack_forget()
            self.setup_gui()
        else:
            self.error_message.set("Invalid username or password")

    # ------------------------------------------------
    # Main GUI
    # ------------------------------------------------
    def setup_gui(self):
        self.canvas = tk.Canvas(self.root)
        self.scrollbar = ttk.Scrollbar(self.root, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")

        main_container = ttk.Frame(self.scrollable_frame)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        title_label = ttk.Label(main_container, text="Temperature Control System", font=("Arial", 16, "bold"))
        title_label.pack(pady=10)

        error_label = ttk.Label(main_container, textvariable=self.error_message, foreground="red")
        error_label.pack()

        # Current readings
        current_readings_frame = ttk.LabelFrame(main_container, text="Current Readings")
        current_readings_frame.pack(fill=tk.X, pady=10)

        ttk.Label(current_readings_frame, text="Current Temperature:").pack()
        ttk.Label(current_readings_frame, textvariable=self.current_temp, font=("Arial", 14)).pack()

        ttk.Label(current_readings_frame, text="Heat Sink Temperature:").pack()
        ttk.Label(current_readings_frame, textvariable=self.heat_sink_temp, font=("Arial", 14)).pack()

        # Connection frame
        connection_frame = ttk.Frame(main_container)
        connection_frame.pack(fill=tk.X, pady=10)

        connect_button = ttk.Button(connection_frame, text="Connect Device", command=self.connect_device)
        connect_button.pack(side=tk.LEFT, padx=5)

        connection_status_label = ttk.Label(connection_frame, textvariable=self.connection_status)
        connection_status_label.pack(side=tk.LEFT, padx=5)

        # Profile frame
        profile_frame = ttk.LabelFrame(main_container, text="Temperature Profile")
        profile_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.profile_table = ttk.Treeview(profile_frame, columns=("T1", "T2", "Stay Time"), show="headings")
        self.profile_table.heading("T1", text="T1 (°C)")
        self.profile_table.heading("T2", text="T2 (°C)")
        self.profile_table.heading("Stay Time", text="Stay Time (min)")
        self.profile_table.pack(fill=tk.BOTH, expand=True)

        input_frame = ttk.Frame(profile_frame)
        input_frame.pack(pady=10)

        ttk.Label(input_frame, text="T2 (°C):").grid(row=0, column=0, padx=5)
        self.t2_entry = ttk.Entry(input_frame)
        self.t2_entry.grid(row=0, column=1, padx=5)

        ttk.Label(input_frame, text="Stay Time (min):").grid(row=0, column=2, padx=5)
        self.stay_time_entry = ttk.Entry(input_frame)
        self.stay_time_entry.grid(row=0, column=3, padx=5)

        add_reading_button = ttk.Button(input_frame, text="Add Profile", command=self.add_reading)
        add_reading_button.grid(row=0, column=4, padx=5)

        button_frame = ttk.Frame(profile_frame)
        button_frame.pack(pady=10)

        start_process_button = ttk.Button(button_frame, text="Start Process", command=self.start_process)
        start_process_button.pack(side=tk.LEFT, padx=5)

        stop_process_button = ttk.Button(button_frame, text="Stop Process", command=self.stop_process)
        stop_process_button.pack(side=tk.LEFT, padx=5)

        # Plot frame
        plot_frame = ttk.LabelFrame(main_container, text="Temperature vs Time")
        plot_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.fig, self.ax = plt.subplots()
        self.canvas_plot = FigureCanvasTkAgg(self.fig, master=plot_frame)
        self.canvas_plot.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def connect_device(self):
        try:
            self.connection_status.set(True)
            self.error_message.set("")
        except Exception as e:
            self.error_message.set(f"Failed to connect to the device: {e}")

    def add_reading(self):
        """
        Adds a new temperature step to the profile. The T1 is either the initial
        temperature or the previous step's T2.
        """
        try:
            t1_value = self.initial_temp.get() if not self.temp_profiles else self.temp_profiles[-1]["T2"]
            t2_value = float(self.t2_entry.get())
            stay_time = float(self.stay_time_entry.get())

            new_profile = {
                "T1": t1_value,
                "T2": t2_value,
                "Stay Time": stay_time
            }
            self.temp_profiles.append(new_profile)
            self.update_profile_table()

            self.t2_entry.delete(0, tk.END)
            self.stay_time_entry.delete(0, tk.END)
        except ValueError:
            self.error_message.set("Invalid input. Please enter numeric values for T2 and stay time.")

    def update_profile_table(self):
        for row in self.profile_table.get_children():
            self.profile_table.delete(row)

        for profile in self.temp_profiles:
            self.profile_table.insert(
                "",
                tk.END,
                values=(profile["T1"], profile["T2"], profile["Stay Time"])
            )

    # ------------------------------------------------
    # Start / Stop Process
    # ------------------------------------------------
    def start_process(self):
        if not self.connection_status.get():
            self.error_message.set("Device not connected")
            return
        if not self.temp_profiles:
            self.error_message.set("No temperature profiles added")
            return

        self.is_processing.set(True)
        self.error_message.set("")
        self.time_stamps = []
        self.temperatures = []
        self.start_time = time.time()

        # Launch the control loop in a separate thread
        threading.Thread(target=self.control_loop, daemon=True).start()

    def stop_process(self):
        self.is_processing.set(False)

    # ------------------------------------------------
    # Control Logic
    # ------------------------------------------------
    def control_loop(self):
        """
        For each profile:
          1. Start from T1 and step up/down to T2 in 20°C increments.
          2. Once T2 is reached, dwell for 'Stay Time'.
        """
        if self.power_supply:
            # Reset the Tenma power supply to 0 A at the start of the process
            self.power_supply.output_off()
            self.power_supply.set_voltage(30.0)    # Adjust as needed
            self.power_supply.set_current(0.0)
            self.power_supply.output_on()

        for profile in self.temp_profiles:
            if not self.is_processing.get():
                break

            T1 = profile["T1"]
            T2 = profile["T2"]
            stay_time = profile["Stay Time"]

            # Generate increments of 20 degrees from T1 to T2
            increments = self.get_temp_increments(T1, T2, step=20)

            # Step through each increment
            for inc_target in increments:
                if not self.is_processing.get():
                    break

                self.set_temp.set(inc_target)
                # Heat/cool until we reach inc_target (within some tolerance)
                while self.is_processing.get():
                    temp = self.sensor.temperature if self.sensor else T1  # fallback to T1 if no sensor
                    self.current_temp.set(temp)

                    # PID output
                    output_current = self.pid.compute(self.set_temp.get(), temp)
                    self.current_output.set(output_current)

                    # Update Tenma supply current
                    if self.power_supply:
                        try:
                            self.power_supply.set_current(output_current)
                        except Exception as e:
                            print(f"Warning: Could not set power supply current: {e}")

                    # Logging for plotting
                    self.time_stamps.append(time.time() - self.start_time)
                    self.temperatures.append(temp)
                    self.update_plot()

                    # Check if we've reached or surpassed the increment target
                    if (T2 >= T1 and temp >= inc_target - 0.5) or \
                       (T2 < T1  and temp <= inc_target + 0.5):
                        break

                    time.sleep(1)

            # Once final increment (T2) is reached, stay for the specified time
            stay_start = time.time()
            while self.is_processing.get() and (time.time() - stay_start < stay_time * 60):
                temp = self.sensor.temperature if self.sensor else T2
                self.current_temp.set(temp)

                # PID output (holding T2)
                output_current = self.pid.compute(T2, temp)
                self.current_output.set(output_current)

                # Update power supply
                if self.power_supply:
                    try:
                        self.power_supply.set_current(output_current)
                    except Exception as e:
                        print(f"Warning: Could not set power supply current: {e}")

                # Logging for plotting
                self.time_stamps.append(time.time() - self.start_time)
                self.temperatures.append(temp)
                self.update_plot()
                time.sleep(1)

            if not self.is_processing.get():
                break

        # After all profiles or if stopped, turn off the supply
        if self.power_supply:
            self.power_supply.set_current(0.0)
            self.power_supply.output_off()

    # ------------------------------------------------
    # Utility: Generate 20°C increments
    # ------------------------------------------------
    def get_temp_increments(self, T1, T2, step=20):
        """
        Return a list of intermediate setpoints in 20°C increments
        from T1 to T2 (inclusive).
        Example: T1=25, T2=85 => [45, 65, 85]
        """
        increments = []
        if T2 > T1:
            current = T1
            while current < T2:
                next_temp = current + step
                if next_temp > T2:
                    next_temp = T2
                increments.append(next_temp)
                current = next_temp
        else:
            # Handle the case if T2 < T1 (cooling in steps of -20°C)
            current = T1
            while current > T2:
                next_temp = current - step
                if next_temp < T2:
                    next_temp = T2
                increments.append(next_temp)
                current = next_temp
        return increments

    # ------------------------------------------------
    # Plotting
    # ------------------------------------------------
    def update_plot(self):
        self.ax.clear()
        self.ax.plot(self.time_stamps, self.temperatures, label="Temperature")
        self.ax.set_xlabel("Time (s)")
        self.ax.set_ylabel("Temperature (°C)")
        self.ax.legend()
        self.canvas_plot.draw()

    # ------------------------------------------------
    # CSV Logging
    # ------------------------------------------------
    def setup_logging(self):
        """
        Sets up a CSV logging file with headers if it doesn't exist.
        """
        if not os.path.exists(self.data_log_file):
            with open(self.data_log_file, "w", newline="") as file:
                writer = csv.writer(file)
                writer.writerow(["Time (s)", "Set Temperature (°C)",
                                 "Current Temperature (°C)", "Output Current (A)"])


if __name__ == "__main__":
    root = tk.Tk()
    app = HeaterControlApp(root)
    root.mainloop()
